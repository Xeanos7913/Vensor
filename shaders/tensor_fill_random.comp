#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference_uvec2 : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// --- Tensor buffer layouts ---
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_data   { float data[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_grad   { float grad[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_strides{ int  strides[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_shape  { int  dims[]; };

struct TensorImpl {
    tensor_data    data;
    tensor_grad    grad;
    tensor_strides strides;
    tensor_shape   shape;
    uint numel;
    uint ndim;
    uint requires_grad;
    uint is_leaf;
};

struct TensorFillContext {
    TensorImpl tensor;
    uint init_type;     // 0=Uniform, 1=Normal, 2=Xavier/Glorot, 3=He/Kaiming, 4=Constant
    uint fan_in;        // Number of input connections (for Xavier/He)
    uint fan_out;       // Number of output connections (for Xavier)
    float param1;       // mean for Normal, constant value, or min for Uniform
    float param2;       // stddev for Normal, unused, or max for Uniform
    uint seed;
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer ContextBuffer {
    TensorFillContext ctx;
};

layout(push_constant) uniform PushConstants {
    ContextBuffer context;
    uvec3 grid_size;
    uint  kernel_type;
} push;

// ---------------- RNG helpers ----------------
uint finalizer32(uint x) {
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
}

uint make_seed(uint base, uint index, uvec3 gid) {
    uint s = base ^ (index * 0x9E3779B9u);
    s ^= gid.x * 0x6a09e667u;
    s ^= gid.y * 0xbb67ae85u;
    s ^= gid.z * 0x3c6ef372u;
    return finalizer32(s);
}

float hash_to_float(uint h) {
    uint top24 = (h >> 8u) & 0x00FFFFFFu;
    return float(top24) / 16777216.0;
}

float random_uniform_01(uint seed) {
    return hash_to_float(finalizer32(seed));
}

// Box-Muller transform for Gaussian
float random_gaussian(uint seed, float mean, float stddev) {
    uint s1 = finalizer32(seed);
    uint s2 = finalizer32(s1 + 0x9E3779B9u);
    float u1 = max(hash_to_float(s1), 1e-7);
    float u2 = hash_to_float(s2);
    float z = sqrt(-2.0 * log(u1)) * cos(6.28318530718 * u2);
    return mean + z * stddev;
}

// ---------------- Main ----------------
void main() {
    uvec3 gid = gl_WorkGroupID;
    uint local_id = gl_LocalInvocationIndex;
    uint global_id = gid.x * gl_WorkGroupSize.x + local_id;
    
    TensorFillContext ctx = push.context.ctx;
    TensorImpl tensor = ctx.tensor;
    uint index = global_id;
    
    if (index >= tensor.numel) return;
    
    uint seed = make_seed(ctx.seed, index, gid);
    float val;
    
    switch(ctx.init_type) {
        case 0u: // Uniform [param1, param2]
            val = ctx.param1 + random_uniform_01(seed) * (ctx.param2 - ctx.param1);
            break;
            
        case 1u: // Normal (mean=param1, stddev=param2)
            val = random_gaussian(seed, ctx.param1, ctx.param2);
            break;
            
        case 2u: // Xavier/Glorot: Normal(0, sqrt(2/(fan_in + fan_out)))
            {
                float stddev = sqrt(2.0 / float(ctx.fan_in + ctx.fan_out));
                val = random_gaussian(seed, 0.0, stddev);
            }
            break;
            
        case 3u: // He/Kaiming: Normal(0, sqrt(2/fan_in))
            {
                float stddev = sqrt(2.0 / float(ctx.fan_in));
                val = random_gaussian(seed, 0.0, stddev);
            }
            break;
            
        case 4u: // Constant value (param1)
            val = ctx.param1;
            break;
            
        default:
            val = 0.0;
            break;
    }
    
    tensor.data.data[index] = val;
}