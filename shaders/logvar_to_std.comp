#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference_uvec2 : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(buffer_reference, std430, scalar) buffer tensor_data {
    float data[];
};
layout(buffer_reference, std430, scalar) buffer tensor_grad {
    float grad[];
};
layout(buffer_reference, std430, scalar) buffer tensor_strides {
    int strides[];
};
layout(buffer_reference, std430, scalar) buffer tensor_shape {
    int dims[];
};

struct TensorImpl {
    tensor_data    data;
    tensor_grad    grad;
    tensor_strides strides;
    tensor_shape   shape;
    uint numel, ndim, requires_grad, is_leaf;
};

struct LogVarToStd {
    TensorImpl logvar;        // input: log-variance tensor
    TensorImpl std_out;       // output: standard deviation tensor
    uint accumulate_grad;     // 0: overwrite, 1: += for grads
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer ContextBuffer { 
    LogVarToStd ctx; 
};

layout(push_constant) uniform PushConstants {
    ContextBuffer context;
    uvec3 grid_size;
} push;

void forward_pass() {
    uint gid = gl_GlobalInvocationID.x;
    LogVarToStd op = push.context.ctx;
    
    // Check bounds
    if (gid >= op.logvar.numel) {
        return;
    }
    
    // Read log-variance value
    float logvar_val = op.logvar.data.data[gid];
    
    // Compute std = exp(0.5 * logvar)
    float std_val = exp(0.5 * logvar_val);
    
    // Store result to output tensor
    op.std_out.data.data[gid] = std_val;
}

void main() {
    forward_pass();
}