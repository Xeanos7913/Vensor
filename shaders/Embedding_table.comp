#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference_uvec2 : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_data { float data[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_grad { float grad[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_strides { int strides[]; };
layout(buffer_reference, std430, buffer_reference_align = 16) buffer tensor_shape { int dims[]; };

struct TensorImpl {
    tensor_data    data;
    tensor_grad    grad;
    tensor_strides strides;
    tensor_shape   shape;
    uint numel;
    uint ndim;
    uint requires_grad;
    uint is_leaf;
};

struct EmbeddingTableContext {
    TensorImpl embedding_tensor;   // (vocab_size, embedding_dim)
    TensorImpl token_indices;      // (B, token_count)
    TensorImpl output_tensor;      // (B, token_count, embedding_dim)
};

layout(buffer_reference, std430, buffer_reference_align = 16) buffer ContextBuffer { EmbeddingTableContext ctx; };

layout(push_constant) uniform PushConstants {
    ContextBuffer ctx;
    uvec3 grid_size;
    uint kernel_type;
} push;

uint off2or3(const TensorImpl t, uint b, uint i, uint j) {
    if (t.ndim == 2u)
        return i * t.strides.strides[0] + j * t.strides.strides[1];
    else
        return b * t.strides.strides[0] + i * t.strides.strides[1] + j * t.strides.strides[2];
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    EmbeddingTableContext ctx = push.ctx.ctx;

    uint B = ctx.token_indices.shape.dims[0];
    uint token_count = ctx.token_indices.shape.dims[1];
    uint embed_dim = ctx.embedding_tensor.shape.dims[1];
    uint total = B * token_count * embed_dim;

    if (gid >= total) return;

    uint b = gid / (token_count * embed_dim);
    uint t = (gid / embed_dim) % token_count;
    uint e = gid % embed_dim;

    // lookup token index
    uint token_index = uint(ctx.token_indices.data.data[b * ctx.token_indices.strides.strides[0] +
                                                        t * ctx.token_indices.strides.strides[1]]);

    // get embedding value
    float value = ctx.embedding_tensor.data.data[token_index * ctx.embedding_tensor.strides.strides[0] +
                                                 e * ctx.embedding_tensor.strides.strides[1]];

    // write output
    ctx.output_tensor.data.data[
        b * ctx.output_tensor.strides.strides[0] +
        t * ctx.output_tensor.strides.strides[1] +
        e * ctx.output_tensor.strides.strides[2]
    ] = value;
}